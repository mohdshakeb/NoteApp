{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@supabase/storage-js/dist/index.mjs","sources":["file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/lib/errors.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/lib/helpers.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/lib/fetch.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/packages/StreamDownloadBuilder.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/packages/BlobDownloadBuilder.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/packages/StorageFileApi.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/lib/version.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/lib/constants.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/packages/StorageBucketApi.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/packages/StorageAnalyticsClient.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/lib/vectors/constants.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/lib/vectors/errors.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/lib/vectors/helpers.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/lib/vectors/fetch.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/lib/vectors/VectorIndexApi.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/lib/vectors/VectorDataApi.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/lib/vectors/VectorBucketApi.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/lib/vectors/StorageVectorsClient.ts","file:///Users/shakeb/Downloads/NoteApp_Migration/node_modules/%40supabase/storage-js/src/StorageClient.ts"],"sourcesContent":["export class StorageError extends Error {\n  protected __isStorageError = true\n\n  constructor(message: string) {\n    super(message)\n    this.name = 'StorageError'\n  }\n}\n\nexport function isStorageError(error: unknown): error is StorageError {\n  return typeof error === 'object' && error !== null && '__isStorageError' in error\n}\n\nexport class StorageApiError extends StorageError {\n  status: number\n  statusCode: string\n\n  constructor(message: string, status: number, statusCode: string) {\n    super(message)\n    this.name = 'StorageApiError'\n    this.status = status\n    this.statusCode = statusCode\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n      statusCode: this.statusCode,\n    }\n  }\n}\n\nexport class StorageUnknownError extends StorageError {\n  originalError: unknown\n\n  constructor(message: string, originalError: unknown) {\n    super(message)\n    this.name = 'StorageUnknownError'\n    this.originalError = originalError\n  }\n}\n","type Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  if (customFetch) {\n    return (...args) => customFetch(...args)\n  }\n  return (...args) => fetch(...args)\n}\n\nexport const resolveResponse = (): typeof Response => {\n  return Response\n}\n\nexport const recursiveToCamel = (item: Record<string, any>): unknown => {\n  if (Array.isArray(item)) {\n    return item.map((el) => recursiveToCamel(el))\n  } else if (typeof item === 'function' || item !== Object(item)) {\n    return item\n  }\n\n  const result: Record<string, any> = {}\n  Object.entries(item).forEach(([key, value]) => {\n    const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ''))\n    result[newKey] = recursiveToCamel(value)\n  })\n\n  return result\n}\n\n/**\n * Determine if input is a plain object\n * An object is plain if it's created by either {}, new Object(), or Object.create(null)\n * source: https://github.com/sindresorhus/is-plain-obj\n */\nexport const isPlainObject = (value: object): boolean => {\n  if (typeof value !== 'object' || value === null) {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n  return (\n    (prototype === null ||\n      prototype === Object.prototype ||\n      Object.getPrototypeOf(prototype) === null) &&\n    !(Symbol.toStringTag in value) &&\n    !(Symbol.iterator in value)\n  )\n}\n\n/**\n * Validates if a given bucket name is valid according to Supabase Storage API rules\n * Mirrors backend validation from: storage/src/storage/limits.ts:isValidBucketName()\n *\n * Rules:\n * - Length: 1-100 characters\n * - Allowed characters: alphanumeric (a-z, A-Z, 0-9), underscore (_), and safe special characters\n * - Safe special characters: ! - . * ' ( ) space & $ @ = ; : + , ?\n * - Forbidden: path separators (/, \\), path traversal (..), leading/trailing whitespace\n *\n * AWS S3 Reference: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html\n *\n * @param bucketName - The bucket name to validate\n * @returns true if valid, false otherwise\n */\nexport const isValidBucketName = (bucketName: string): boolean => {\n  if (!bucketName || typeof bucketName !== 'string') {\n    return false\n  }\n\n  // Check length constraints (1-100 characters)\n  if (bucketName.length === 0 || bucketName.length > 100) {\n    return false\n  }\n\n  // Check for leading/trailing whitespace\n  if (bucketName.trim() !== bucketName) {\n    return false\n  }\n\n  // Explicitly reject path separators (security)\n  // Note: Consecutive periods (..) are allowed by backend - the AWS restriction\n  // on relative paths applies to object keys, not bucket names\n  if (bucketName.includes('/') || bucketName.includes('\\\\')) {\n    return false\n  }\n\n  // Validate against allowed character set\n  // Pattern matches backend regex: /^(\\w|!|-|\\.|\\*|'|\\(|\\)| |&|\\$|@|=|;|:|\\+|,|\\?)*$/\n  // This explicitly excludes path separators (/, \\) and other problematic characters\n  const bucketNameRegex = /^[\\w!.\\*'() &$@=;:+,?-]+$/\n  return bucketNameRegex.test(bucketName)\n}\n","import { StorageApiError, StorageUnknownError } from './errors'\nimport { isPlainObject, resolveResponse } from './helpers'\nimport { FetchParameters } from './types'\n\nexport type Fetch = typeof fetch\n\nexport interface FetchOptions {\n  headers?: {\n    [key: string]: string\n  }\n  duplex?: string\n  noResolveJson?: boolean\n}\n\nexport type RequestMethodType = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD'\n\nconst _getErrorMessage = (err: any): string =>\n  err.msg ||\n  err.message ||\n  err.error_description ||\n  (typeof err.error === 'string' ? err.error : err.error?.message) ||\n  JSON.stringify(err)\n\nconst handleError = async (\n  error: unknown,\n  reject: (reason?: any) => void,\n  options?: FetchOptions\n) => {\n  const Res = await resolveResponse()\n\n  if (error instanceof Res && !options?.noResolveJson) {\n    error\n      .json()\n      .then((err) => {\n        const status = error.status || 500\n        const statusCode = err?.statusCode || status + ''\n        reject(new StorageApiError(_getErrorMessage(err), status, statusCode))\n      })\n      .catch((err) => {\n        reject(new StorageUnknownError(_getErrorMessage(err), err))\n      })\n  } else {\n    reject(new StorageUnknownError(_getErrorMessage(error), error))\n  }\n}\n\nconst _getRequestParams = (\n  method: RequestMethodType,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n) => {\n  const params: { [k: string]: any } = { method, headers: options?.headers || {} }\n\n  if (method === 'GET' || !body) {\n    return params\n  }\n\n  if (isPlainObject(body)) {\n    params.headers = { 'Content-Type': 'application/json', ...options?.headers }\n    params.body = JSON.stringify(body)\n  } else {\n    params.body = body\n  }\n\n  if (options?.duplex) {\n    params.duplex = options.duplex\n  }\n\n  return { ...params, ...parameters }\n}\n\nasync function _handleRequest(\n  fetcher: Fetch,\n  method: RequestMethodType,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n): Promise<any> {\n  return new Promise((resolve, reject) => {\n    fetcher(url, _getRequestParams(method, options, parameters, body))\n      .then((result) => {\n        if (!result.ok) throw result\n        if (options?.noResolveJson) return result\n        return result.json()\n      })\n      .then((data) => resolve(data))\n      .catch((error) => handleError(error, reject, options))\n  })\n}\n\nexport async function get(\n  fetcher: Fetch,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'GET', url, options, parameters)\n}\n\nexport async function post(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'POST', url, options, parameters, body)\n}\n\nexport async function put(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'PUT', url, options, parameters, body)\n}\n\nexport async function head(\n  fetcher: Fetch,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(\n    fetcher,\n    'HEAD',\n    url,\n    {\n      ...options,\n      noResolveJson: true,\n    },\n    parameters\n  )\n}\n\nexport async function remove(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'DELETE', url, options, parameters, body)\n}\n","import { isStorageError } from '../lib/errors'\nimport { DownloadResult } from '../lib/types'\n\nexport default class StreamDownloadBuilder implements PromiseLike<DownloadResult<ReadableStream>> {\n  constructor(\n    private downloadFn: () => Promise<Response>,\n    private shouldThrowOnError: boolean\n  ) {}\n\n  then<TResult1 = DownloadResult<ReadableStream>, TResult2 = never>(\n    onfulfilled?:\n      | ((value: DownloadResult<ReadableStream>) => TResult1 | PromiseLike<TResult1>)\n      | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null\n  ): Promise<TResult1 | TResult2> {\n    return this.execute().then(onfulfilled, onrejected)\n  }\n\n  private async execute(): Promise<DownloadResult<ReadableStream>> {\n    try {\n      const result = await this.downloadFn()\n\n      return {\n        data: result.body as ReadableStream,\n        error: null,\n      }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n}\n","import { isStorageError } from '../lib/errors'\nimport { DownloadResult } from '../lib/types'\nimport StreamDownloadBuilder from './StreamDownloadBuilder'\n\nexport default class BlobDownloadBuilder implements Promise<DownloadResult<Blob>> {\n  readonly [Symbol.toStringTag]: string = 'BlobDownloadBuilder'\n  private promise: Promise<DownloadResult<Blob>> | null = null\n\n  constructor(\n    private downloadFn: () => Promise<Response>,\n    private shouldThrowOnError: boolean\n  ) {}\n\n  asStream(): StreamDownloadBuilder {\n    return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError)\n  }\n\n  then<TResult1 = DownloadResult<Blob>, TResult2 = never>(\n    onfulfilled?: ((value: DownloadResult<Blob>) => TResult1 | PromiseLike<TResult1>) | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null\n  ): Promise<TResult1 | TResult2> {\n    return this.getPromise().then(onfulfilled, onrejected)\n  }\n\n  catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null\n  ): Promise<DownloadResult<Blob> | TResult> {\n    return this.getPromise().catch(onrejected)\n  }\n\n  finally(onfinally?: (() => void) | null): Promise<DownloadResult<Blob>> {\n    return this.getPromise().finally(onfinally)\n  }\n\n  private getPromise(): Promise<DownloadResult<Blob>> {\n    if (!this.promise) {\n      this.promise = this.execute()\n    }\n    return this.promise\n  }\n\n  private async execute(): Promise<DownloadResult<Blob>> {\n    try {\n      const result = await this.downloadFn()\n\n      return {\n        data: await result.blob(),\n        error: null,\n      }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n}\n","import { isStorageError, StorageError, StorageUnknownError } from '../lib/errors'\nimport { Fetch, get, head, post, put, remove } from '../lib/fetch'\nimport { recursiveToCamel, resolveFetch } from '../lib/helpers'\nimport {\n  FileObject,\n  FileOptions,\n  SearchOptions,\n  FetchParameters,\n  TransformOptions,\n  DestinationOptions,\n  FileObjectV2,\n  Camelize,\n  SearchV2Options,\n  SearchV2Result,\n} from '../lib/types'\nimport BlobDownloadBuilder from './BlobDownloadBuilder'\n\nconst DEFAULT_SEARCH_OPTIONS = {\n  limit: 100,\n  offset: 0,\n  sortBy: {\n    column: 'name',\n    order: 'asc',\n  },\n}\n\nconst DEFAULT_FILE_OPTIONS: FileOptions = {\n  cacheControl: '3600',\n  contentType: 'text/plain;charset=UTF-8',\n  upsert: false,\n}\n\ntype FileBody =\n  | ArrayBuffer\n  | ArrayBufferView\n  | Blob\n  | Buffer\n  | File\n  | FormData\n  | NodeJS.ReadableStream\n  | ReadableStream<Uint8Array>\n  | URLSearchParams\n  | string\n\nexport default class StorageFileApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected bucketId?: string\n  protected fetch: Fetch\n  protected shouldThrowOnError = false\n\n  constructor(\n    url: string,\n    headers: { [key: string]: string } = {},\n    bucketId?: string,\n    fetch?: Fetch\n  ) {\n    this.url = url\n    this.headers = headers\n    this.bucketId = bucketId\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Enable throwing errors instead of returning them.\n   *\n   * @category File Buckets\n   */\n  public throwOnError(): this {\n    this.shouldThrowOnError = true\n    return this\n  }\n\n  /**\n   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n   *\n   * @param method HTTP method.\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  private async uploadOrUpdate(\n    method: 'POST' | 'PUT',\n    path: string,\n    fileBody: FileBody,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { id: string; path: string; fullPath: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let body\n      const options = { ...DEFAULT_FILE_OPTIONS, ...fileOptions }\n      let headers: Record<string, string> = {\n        ...this.headers,\n        ...(method === 'POST' && { 'x-upsert': String(options.upsert as boolean) }),\n      }\n\n      const metadata = options.metadata\n\n      if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n        body = new FormData()\n        body.append('cacheControl', options.cacheControl as string)\n        if (metadata) {\n          body.append('metadata', this.encodeMetadata(metadata))\n        }\n        body.append('', fileBody)\n      } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n        body = fileBody\n        // Only append if not already present\n        if (!body.has('cacheControl')) {\n          body.append('cacheControl', options.cacheControl as string)\n        }\n        if (metadata && !body.has('metadata')) {\n          body.append('metadata', this.encodeMetadata(metadata))\n        }\n      } else {\n        body = fileBody\n        headers['cache-control'] = `max-age=${options.cacheControl}`\n        headers['content-type'] = options.contentType as string\n\n        if (metadata) {\n          headers['x-metadata'] = this.toBase64(this.encodeMetadata(metadata))\n        }\n\n        // Node.js streams require duplex option for fetch in Node 20+\n        // Check for both web ReadableStream and Node.js streams\n        const isStream =\n          (typeof ReadableStream !== 'undefined' && body instanceof ReadableStream) ||\n          (body && typeof body === 'object' && 'pipe' in body && typeof body.pipe === 'function')\n\n        if (isStream && !options.duplex) {\n          options.duplex = 'half'\n        }\n      }\n\n      if (fileOptions?.headers) {\n        headers = { ...headers, ...fileOptions.headers }\n      }\n\n      const cleanPath = this._removeEmptyFolders(path)\n      const _path = this._getFinalPath(cleanPath)\n      const data = await (method == 'PUT' ? put : post)(\n        this.fetch,\n        `${this.url}/object/${_path}`,\n        body as object,\n        { headers, ...(options?.duplex ? { duplex: options.duplex } : {}) }\n      )\n\n      return {\n        data: { path: cleanPath, id: data.Id, fullPath: data.Key },\n        error: null,\n      }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Uploads a file to an existing bucket.\n   *\n   * @category File Buckets\n   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   * @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n   * @returns Promise with response containing file path, id, and fullPath or error\n   *\n   * @example Upload file\n   * ```js\n   * const avatarFile = event.target.files[0]\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .upload('public/avatar1.png', avatarFile, {\n   *     cacheControl: '3600',\n   *     upsert: false\n   *   })\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": {\n   *     \"path\": \"public/avatar1.png\",\n   *     \"fullPath\": \"avatars/public/avatar1.png\"\n   *   },\n   *   \"error\": null\n   * }\n   * ```\n   *\n   * @example Upload file using `ArrayBuffer` from base64 file data\n   * ```js\n   * import { decode } from 'base64-arraybuffer'\n   *\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .upload('public/avatar1.png', decode('base64FileData'), {\n   *     contentType: 'image/png'\n   *   })\n   * ```\n   */\n  async upload(\n    path: string,\n    fileBody: FileBody,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { id: string; path: string; fullPath: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    return this.uploadOrUpdate('POST', path, fileBody, fileOptions)\n  }\n\n  /**\n   * Upload a file with a token generated from `createSignedUploadUrl`.\n   *\n   * @category File Buckets\n   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param token The token generated from `createSignedUploadUrl`\n   * @param fileBody The body of the file to be stored in the bucket.\n   * @param fileOptions HTTP headers (cacheControl, contentType, etc.).\n   * **Note:** The `upsert` option has no effect here. To enable upsert behavior,\n   * pass `{ upsert: true }` when calling `createSignedUploadUrl()` instead.\n   * @returns Promise with response containing file path and fullPath or error\n   *\n   * @example Upload to a signed URL\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": {\n   *     \"path\": \"folder/cat.jpg\",\n   *     \"fullPath\": \"avatars/folder/cat.jpg\"\n   *   },\n   *   \"error\": null\n   * }\n   * ```\n   */\n  async uploadToSignedUrl(\n    path: string,\n    token: string,\n    fileBody: FileBody,\n    fileOptions?: FileOptions\n  ) {\n    const cleanPath = this._removeEmptyFolders(path)\n    const _path = this._getFinalPath(cleanPath)\n\n    const url = new URL(this.url + `/object/upload/sign/${_path}`)\n    url.searchParams.set('token', token)\n\n    try {\n      let body\n      const options = { upsert: DEFAULT_FILE_OPTIONS.upsert, ...fileOptions }\n      const headers: Record<string, string> = {\n        ...this.headers,\n        ...{ 'x-upsert': String(options.upsert as boolean) },\n      }\n\n      if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n        body = new FormData()\n        body.append('cacheControl', options.cacheControl as string)\n        body.append('', fileBody)\n      } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n        body = fileBody\n        body.append('cacheControl', options.cacheControl as string)\n      } else {\n        body = fileBody\n        headers['cache-control'] = `max-age=${options.cacheControl}`\n        headers['content-type'] = options.contentType as string\n      }\n\n      const data = await put(this.fetch, url.toString(), body as object, { headers })\n\n      return {\n        data: { path: cleanPath, fullPath: data.Key },\n        error: null,\n      }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a signed upload URL.\n   * Signed upload URLs can be used to upload files to the bucket without further authentication.\n   * They are valid for 2 hours.\n   *\n   * @category File Buckets\n   * @param path The file path, including the current file name. For example `folder/image.png`.\n   * @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n   * @returns Promise with response containing signed upload URL, token, and path or error\n   *\n   * @example Create Signed Upload URL\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .createSignedUploadUrl('folder/cat.jpg')\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": {\n   *     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/upload/sign/avatars/folder/cat.jpg?token=<TOKEN>\",\n   *     \"path\": \"folder/cat.jpg\",\n   *     \"token\": \"<TOKEN>\"\n   *   },\n   *   \"error\": null\n   * }\n   * ```\n   */\n  async createSignedUploadUrl(\n    path: string,\n    options?: { upsert: boolean }\n  ): Promise<\n    | {\n        data: { signedUrl: string; token: string; path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let _path = this._getFinalPath(path)\n\n      const headers = { ...this.headers }\n\n      if (options?.upsert) {\n        headers['x-upsert'] = 'true'\n      }\n\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/upload/sign/${_path}`,\n        {},\n        { headers }\n      )\n\n      const url = new URL(this.url + data.url)\n\n      const token = url.searchParams.get('token')\n\n      if (!token) {\n        throw new StorageError('No token returned by API')\n      }\n\n      return { data: { signedUrl: url.toString(), path, token }, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Replaces an existing file at the specified path with a new one.\n   *\n   * @category File Buckets\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n   * @param fileBody The body of the file to be stored in the bucket.\n   * @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n   * @returns Promise with response containing file path, id, and fullPath or error\n   *\n   * @example Update file\n   * ```js\n   * const avatarFile = event.target.files[0]\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .update('public/avatar1.png', avatarFile, {\n   *     cacheControl: '3600',\n   *     upsert: true\n   *   })\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": {\n   *     \"path\": \"public/avatar1.png\",\n   *     \"fullPath\": \"avatars/public/avatar1.png\"\n   *   },\n   *   \"error\": null\n   * }\n   * ```\n   *\n   * @example Update file using `ArrayBuffer` from base64 file data\n   * ```js\n   * import {decode} from 'base64-arraybuffer'\n   *\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .update('public/avatar1.png', decode('base64FileData'), {\n   *     contentType: 'image/png'\n   *   })\n   * ```\n   */\n  async update(\n    path: string,\n    fileBody:\n      | ArrayBuffer\n      | ArrayBufferView\n      | Blob\n      | Buffer\n      | File\n      | FormData\n      | NodeJS.ReadableStream\n      | ReadableStream<Uint8Array>\n      | URLSearchParams\n      | string,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { id: string; path: string; fullPath: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    return this.uploadOrUpdate('PUT', path, fileBody, fileOptions)\n  }\n\n  /**\n   * Moves an existing file to a new path in the same bucket.\n   *\n   * @category File Buckets\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n   * @param options The destination options.\n   * @returns Promise with response containing success message or error\n   *\n   * @example Move file\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .move('public/avatar1.png', 'private/avatar2.png')\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": {\n   *     \"message\": \"Successfully moved\"\n   *   },\n   *   \"error\": null\n   * }\n   * ```\n   */\n  async move(\n    fromPath: string,\n    toPath: string,\n    options?: DestinationOptions\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/move`,\n        {\n          bucketId: this.bucketId,\n          sourceKey: fromPath,\n          destinationKey: toPath,\n          destinationBucket: options?.destinationBucket,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Copies an existing file to a new path in the same bucket.\n   *\n   * @category File Buckets\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n   * @param options The destination options.\n   * @returns Promise with response containing copied file path or error\n   *\n   * @example Copy file\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .copy('public/avatar1.png', 'private/avatar2.png')\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": {\n   *     \"path\": \"avatars/private/avatar2.png\"\n   *   },\n   *   \"error\": null\n   * }\n   * ```\n   */\n  async copy(\n    fromPath: string,\n    toPath: string,\n    options?: DestinationOptions\n  ): Promise<\n    | {\n        data: { path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/copy`,\n        {\n          bucketId: this.bucketId,\n          sourceKey: fromPath,\n          destinationKey: toPath,\n          destinationBucket: options?.destinationBucket,\n        },\n        { headers: this.headers }\n      )\n      return { data: { path: data.Key }, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n   *\n   * @category File Buckets\n   * @param path The file path, including the current file name. For example `folder/image.png`.\n   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   * @param options.transform Transform the asset before serving it to the client.\n   * @returns Promise with response containing signed URL or error\n   *\n   * @example Create Signed URL\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .createSignedUrl('folder/avatar1.png', 60)\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": {\n   *     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n   *   },\n   *   \"error\": null\n   * }\n   * ```\n   *\n   * @example Create a signed URL for an asset with transformations\n   * ```js\n   * const { data } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .createSignedUrl('folder/avatar1.png', 60, {\n   *     transform: {\n   *       width: 100,\n   *       height: 100,\n   *     }\n   *   })\n   * ```\n   *\n   * @example Create a signed URL which triggers the download of the asset\n   * ```js\n   * const { data } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .createSignedUrl('folder/avatar1.png', 60, {\n   *     download: true,\n   *   })\n   * ```\n   */\n  async createSignedUrl(\n    path: string,\n    expiresIn: number,\n    options?: { download?: string | boolean; transform?: TransformOptions }\n  ): Promise<\n    | {\n        data: { signedUrl: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let _path = this._getFinalPath(path)\n\n      let data = await post(\n        this.fetch,\n        `${this.url}/object/sign/${_path}`,\n        { expiresIn, ...(options?.transform ? { transform: options.transform } : {}) },\n        { headers: this.headers }\n      )\n      const downloadQueryParam = options?.download\n        ? `&download=${options.download === true ? '' : options.download}`\n        : ''\n      const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`)\n      data = { signedUrl }\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n   *\n   * @category File Buckets\n   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   * @returns Promise with response containing array of objects with signedUrl, path, and error or error\n   *\n   * @example Create Signed URLs\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": [\n   *     {\n   *       \"error\": null,\n   *       \"path\": \"folder/avatar1.png\",\n   *       \"signedURL\": \"/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\",\n   *       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n   *     },\n   *     {\n   *       \"error\": null,\n   *       \"path\": \"folder/avatar2.png\",\n   *       \"signedURL\": \"/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\",\n   *       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\"\n   *     }\n   *   ],\n   *   \"error\": null\n   * }\n   * ```\n   */\n  async createSignedUrls(\n    paths: string[],\n    expiresIn: number,\n    options?: { download: string | boolean }\n  ): Promise<\n    | {\n        data: { error: string | null; path: string | null; signedUrl: string }[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/sign/${this.bucketId}`,\n        { expiresIn, paths },\n        { headers: this.headers }\n      )\n\n      const downloadQueryParam = options?.download\n        ? `&download=${options.download === true ? '' : options.download}`\n        : ''\n      return {\n        data: data.map((datum: { signedURL: string }) => ({\n          ...datum,\n          signedUrl: datum.signedURL\n            ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`)\n            : null,\n        })),\n        error: null,\n      }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n   *\n   * @category File Buckets\n   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n   * @param options.transform Transform the asset before serving it to the client.\n   * @returns BlobDownloadBuilder instance for downloading the file\n   *\n   * @example Download file\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .download('folder/avatar1.png')\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": <BLOB>,\n   *   \"error\": null\n   * }\n   * ```\n   *\n   * @example Download file with transformations\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .download('folder/avatar1.png', {\n   *     transform: {\n   *       width: 100,\n   *       height: 100,\n   *       quality: 80\n   *     }\n   *   })\n   * ```\n   */\n  download<Options extends { transform?: TransformOptions }>(\n    path: string,\n    options?: Options\n  ): BlobDownloadBuilder {\n    const wantsTransformation = typeof options?.transform !== 'undefined'\n    const renderPath = wantsTransformation ? 'render/image/authenticated' : 'object'\n    const transformationQuery = this.transformOptsToQueryString(options?.transform || {})\n    const queryString = transformationQuery ? `?${transformationQuery}` : ''\n    const _path = this._getFinalPath(path)\n    const downloadFn = () =>\n      get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n        headers: this.headers,\n        noResolveJson: true,\n      })\n    return new BlobDownloadBuilder(downloadFn, this.shouldThrowOnError)\n  }\n\n  /**\n   * Retrieves the details of an existing file.\n   *\n   * @category File Buckets\n   * @param path The file path, including the file name. For example `folder/image.png`.\n   * @returns Promise with response containing file metadata or error\n   *\n   * @example Get file info\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .info('folder/avatar1.png')\n   * ```\n   */\n  async info(path: string): Promise<\n    | {\n        data: Camelize<FileObjectV2>\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    const _path = this._getFinalPath(path)\n\n    try {\n      const data = await get(this.fetch, `${this.url}/object/info/${_path}`, {\n        headers: this.headers,\n      })\n\n      return { data: recursiveToCamel(data) as Camelize<FileObjectV2>, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Checks the existence of a file.\n   *\n   * @category File Buckets\n   * @param path The file path, including the file name. For example `folder/image.png`.\n   * @returns Promise with response containing boolean indicating file existence or error\n   *\n   * @example Check file existence\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .exists('folder/avatar1.png')\n   * ```\n   */\n  async exists(path: string): Promise<\n    | {\n        data: boolean\n        error: null\n      }\n    | {\n        data: boolean\n        error: StorageError\n      }\n  > {\n    const _path = this._getFinalPath(path)\n\n    try {\n      await head(this.fetch, `${this.url}/object/${_path}`, {\n        headers: this.headers,\n      })\n\n      return { data: true, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error) && error instanceof StorageUnknownError) {\n        const originalError = error.originalError as unknown as { status: number }\n\n        if ([400, 404].includes(originalError?.status)) {\n          return { data: false, error }\n        }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n   *\n   * @category File Buckets\n   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   * @param options.transform Transform the asset before serving it to the client.\n   * @returns Object with public URL\n   *\n   * @example Returns the URL for an asset in a public bucket\n   * ```js\n   * const { data } = supabase\n   *   .storage\n   *   .from('public-bucket')\n   *   .getPublicUrl('folder/avatar1.png')\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": {\n   *     \"publicUrl\": \"https://example.supabase.co/storage/v1/object/public/public-bucket/folder/avatar1.png\"\n   *   }\n   * }\n   * ```\n   *\n   * @example Returns the URL for an asset in a public bucket with transformations\n   * ```js\n   * const { data } = supabase\n   *   .storage\n   *   .from('public-bucket')\n   *   .getPublicUrl('folder/avatar1.png', {\n   *     transform: {\n   *       width: 100,\n   *       height: 100,\n   *     }\n   *   })\n   * ```\n   *\n   * @example Returns the URL which triggers the download of an asset in a public bucket\n   * ```js\n   * const { data } = supabase\n   *   .storage\n   *   .from('public-bucket')\n   *   .getPublicUrl('folder/avatar1.png', {\n   *     download: true,\n   *   })\n   * ```\n   */\n  getPublicUrl(\n    path: string,\n    options?: { download?: string | boolean; transform?: TransformOptions }\n  ): { data: { publicUrl: string } } {\n    const _path = this._getFinalPath(path)\n    const _queryString: string[] = []\n\n    const downloadQueryParam = options?.download\n      ? `download=${options.download === true ? '' : options.download}`\n      : ''\n\n    if (downloadQueryParam !== '') {\n      _queryString.push(downloadQueryParam)\n    }\n\n    const wantsTransformation = typeof options?.transform !== 'undefined'\n    const renderPath = wantsTransformation ? 'render/image' : 'object'\n    const transformationQuery = this.transformOptsToQueryString(options?.transform || {})\n\n    if (transformationQuery !== '') {\n      _queryString.push(transformationQuery)\n    }\n\n    let queryString = _queryString.join('&')\n    if (queryString !== '') {\n      queryString = `?${queryString}`\n    }\n\n    return {\n      data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) },\n    }\n  }\n\n  /**\n   * Deletes files within the same bucket\n   *\n   * @category File Buckets\n   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n   * @returns Promise with response containing array of deleted file objects or error\n   *\n   * @example Delete file\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .remove(['folder/avatar1.png'])\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": [],\n   *   \"error\": null\n   * }\n   * ```\n   */\n  async remove(paths: string[]): Promise<\n    | {\n        data: FileObject[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await remove(\n        this.fetch,\n        `${this.url}/object/${this.bucketId}`,\n        { prefixes: paths },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Get file metadata\n   * @param id the file id to retrieve metadata\n   */\n  // async getMetadata(\n  //   id: string\n  // ): Promise<\n  //   | {\n  //       data: Metadata\n  //       error: null\n  //     }\n  //   | {\n  //       data: null\n  //       error: StorageError\n  //     }\n  // > {\n  //   try {\n  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })\n  //     return { data, error: null }\n  //   } catch (error) {\n  //     if (isStorageError(error)) {\n  //       return { data: null, error }\n  //     }\n\n  //     throw error\n  //   }\n  // }\n\n  /**\n   * Update file metadata\n   * @param id the file id to update metadata\n   * @param meta the new file metadata\n   */\n  // async updateMetadata(\n  //   id: string,\n  //   meta: Metadata\n  // ): Promise<\n  //   | {\n  //       data: Metadata\n  //       error: null\n  //     }\n  //   | {\n  //       data: null\n  //       error: StorageError\n  //     }\n  // > {\n  //   try {\n  //     const data = await post(\n  //       this.fetch,\n  //       `${this.url}/metadata/${id}`,\n  //       { ...meta },\n  //       { headers: this.headers }\n  //     )\n  //     return { data, error: null }\n  //   } catch (error) {\n  //     if (isStorageError(error)) {\n  //       return { data: null, error }\n  //     }\n\n  //     throw error\n  //   }\n  // }\n\n  /**\n   * Lists all the files and folders within a path of the bucket.\n   *\n   * @category File Buckets\n   * @param path The folder path.\n   * @param options Search options including limit (defaults to 100), offset, sortBy, and search\n   * @param parameters Optional fetch parameters including signal for cancellation\n   * @returns Promise with response containing array of files or error\n   *\n   * @example List files in a bucket\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .list('folder', {\n   *     limit: 100,\n   *     offset: 0,\n   *     sortBy: { column: 'name', order: 'asc' },\n   *   })\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": [\n   *     {\n   *       \"name\": \"avatar1.png\",\n   *       \"id\": \"e668cf7f-821b-4a2f-9dce-7dfa5dd1cfd2\",\n   *       \"updated_at\": \"2024-05-22T23:06:05.580Z\",\n   *       \"created_at\": \"2024-05-22T23:04:34.443Z\",\n   *       \"last_accessed_at\": \"2024-05-22T23:04:34.443Z\",\n   *       \"metadata\": {\n   *         \"eTag\": \"\\\"c5e8c553235d9af30ef4f6e280790b92\\\"\",\n   *         \"size\": 32175,\n   *         \"mimetype\": \"image/png\",\n   *         \"cacheControl\": \"max-age=3600\",\n   *         \"lastModified\": \"2024-05-22T23:06:05.574Z\",\n   *         \"contentLength\": 32175,\n   *         \"httpStatusCode\": 200\n   *       }\n   *     }\n   *   ],\n   *   \"error\": null\n   * }\n   * ```\n   *\n   * @example Search files in a bucket\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .from('avatars')\n   *   .list('folder', {\n   *     limit: 100,\n   *     offset: 0,\n   *     sortBy: { column: 'name', order: 'asc' },\n   *     search: 'jon'\n   *   })\n   * ```\n   */\n  async list(\n    path?: string,\n    options?: SearchOptions,\n    parameters?: FetchParameters\n  ): Promise<\n    | {\n        data: FileObject[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const body = { ...DEFAULT_SEARCH_OPTIONS, ...options, prefix: path || '' }\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/list/${this.bucketId}`,\n        body,\n        { headers: this.headers },\n        parameters\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * @experimental this method signature might change in the future\n   *\n   * @category File Buckets\n   * @param options search options\n   * @param parameters\n   */\n  async listV2(\n    options?: SearchV2Options,\n    parameters?: FetchParameters\n  ): Promise<\n    | {\n        data: SearchV2Result\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const body = { ...options }\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/list-v2/${this.bucketId}`,\n        body,\n        { headers: this.headers },\n        parameters\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  protected encodeMetadata(metadata: Record<string, any>) {\n    return JSON.stringify(metadata)\n  }\n\n  toBase64(data: string) {\n    if (typeof Buffer !== 'undefined') {\n      return Buffer.from(data).toString('base64')\n    }\n    return btoa(data)\n  }\n\n  private _getFinalPath(path: string) {\n    return `${this.bucketId}/${path.replace(/^\\/+/, '')}`\n  }\n\n  private _removeEmptyFolders(path: string) {\n    return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/')\n  }\n\n  private transformOptsToQueryString(transform: TransformOptions) {\n    const params: string[] = []\n    if (transform.width) {\n      params.push(`width=${transform.width}`)\n    }\n\n    if (transform.height) {\n      params.push(`height=${transform.height}`)\n    }\n\n    if (transform.resize) {\n      params.push(`resize=${transform.resize}`)\n    }\n\n    if (transform.format) {\n      params.push(`format=${transform.format}`)\n    }\n\n    if (transform.quality) {\n      params.push(`quality=${transform.quality}`)\n    }\n\n    return params.join('&')\n  }\n}\n","// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nexport const version = '2.89.0'\n","import { version } from './version'\nexport const DEFAULT_HEADERS = {\n  'X-Client-Info': `storage-js/${version}`,\n}\n","import { DEFAULT_HEADERS } from '../lib/constants'\nimport { isStorageError, StorageError } from '../lib/errors'\nimport { Fetch, get, post, put, remove } from '../lib/fetch'\nimport { resolveFetch } from '../lib/helpers'\nimport { Bucket, BucketType, ListBucketOptions } from '../lib/types'\nimport { StorageClientOptions } from '../StorageClient'\n\nexport default class StorageBucketApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected fetch: Fetch\n  protected shouldThrowOnError = false\n\n  constructor(\n    url: string,\n    headers: { [key: string]: string } = {},\n    fetch?: Fetch,\n    opts?: StorageClientOptions\n  ) {\n    const baseUrl = new URL(url)\n\n    // if legacy uri is used, replace with new storage host (disables request buffering to allow > 50GB uploads)\n    // \"project-ref.supabase.co\" becomes \"project-ref.storage.supabase.co\"\n    if (opts?.useNewHostname) {\n      const isSupabaseHost = /supabase\\.(co|in|red)$/.test(baseUrl.hostname)\n      if (isSupabaseHost && !baseUrl.hostname.includes('storage.supabase.')) {\n        baseUrl.hostname = baseUrl.hostname.replace('supabase.', 'storage.supabase.')\n      }\n    }\n\n    this.url = baseUrl.href.replace(/\\/$/, '')\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Enable throwing errors instead of returning them.\n   *\n   * @category File Buckets\n   */\n  public throwOnError(): this {\n    this.shouldThrowOnError = true\n    return this\n  }\n\n  /**\n   * Retrieves the details of all Storage buckets within an existing project.\n   *\n   * @category File Buckets\n   * @param options Query parameters for listing buckets\n   * @param options.limit Maximum number of buckets to return\n   * @param options.offset Number of buckets to skip\n   * @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')\n   * @param options.sortOrder Sort order ('asc' or 'desc')\n   * @param options.search Search term to filter bucket names\n   * @returns Promise with response containing array of buckets or error\n   *\n   * @example List buckets\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .listBuckets()\n   * ```\n   *\n   * @example List buckets with options\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .listBuckets({\n   *     limit: 10,\n   *     offset: 0,\n   *     sortColumn: 'created_at',\n   *     sortOrder: 'desc',\n   *     search: 'prod'\n   *   })\n   * ```\n   */\n  async listBuckets(options?: ListBucketOptions): Promise<\n    | {\n        data: Bucket[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const queryString = this.listBucketOptionsToQueryString(options)\n      const data = await get(this.fetch, `${this.url}/bucket${queryString}`, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Retrieves the details of an existing Storage bucket.\n   *\n   * @category File Buckets\n   * @param id The unique identifier of the bucket you would like to retrieve.\n   * @returns Promise with response containing bucket details or error\n   *\n   * @example Get bucket\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .getBucket('avatars')\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": {\n   *     \"id\": \"avatars\",\n   *     \"name\": \"avatars\",\n   *     \"owner\": \"\",\n   *     \"public\": false,\n   *     \"file_size_limit\": 1024,\n   *     \"allowed_mime_types\": [\n   *       \"image/png\"\n   *     ],\n   *     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n   *     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n   *   },\n   *   \"error\": null\n   * }\n   * ```\n   */\n  async getBucket(id: string): Promise<\n    | {\n        data: Bucket\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers })\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a new Storage bucket\n   *\n   * @category File Buckets\n   * @param id A unique identifier for the bucket you are creating.\n   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n   * The global file size limit takes precedence over this value.\n   * The default value is null, which doesn't set a per bucket file size limit.\n   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n   * The default value is null, which allows files with all mime types to be uploaded.\n   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n   * @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.\n   *   - default bucket type is `STANDARD`\n   * @returns Promise with response containing newly created bucket name or error\n   *\n   * @example Create bucket\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .createBucket('avatars', {\n   *     public: false,\n   *     allowedMimeTypes: ['image/png'],\n   *     fileSizeLimit: 1024\n   *   })\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": {\n   *     \"name\": \"avatars\"\n   *   },\n   *   \"error\": null\n   * }\n   * ```\n   */\n  async createBucket(\n    id: string,\n    options: {\n      public: boolean\n      fileSizeLimit?: number | string | null\n      allowedMimeTypes?: string[] | null\n      type?: BucketType\n    } = {\n      public: false,\n    }\n  ): Promise<\n    | {\n        data: Pick<Bucket, 'name'>\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/bucket`,\n        {\n          id,\n          name: id,\n          type: options.type,\n          public: options.public,\n          file_size_limit: options.fileSizeLimit,\n          allowed_mime_types: options.allowedMimeTypes,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates a Storage bucket\n   *\n   * @category File Buckets\n   * @param id A unique identifier for the bucket you are updating.\n   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n   * The global file size limit takes precedence over this value.\n   * The default value is null, which doesn't set a per bucket file size limit.\n   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n   * The default value is null, which allows files with all mime types to be uploaded.\n   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n   * @returns Promise with response containing success message or error\n   *\n   * @example Update bucket\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .updateBucket('avatars', {\n   *     public: false,\n   *     allowedMimeTypes: ['image/png'],\n   *     fileSizeLimit: 1024\n   *   })\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": {\n   *     \"message\": \"Successfully updated\"\n   *   },\n   *   \"error\": null\n   * }\n   * ```\n   */\n  async updateBucket(\n    id: string,\n    options: {\n      public: boolean\n      fileSizeLimit?: number | string | null\n      allowedMimeTypes?: string[] | null\n    }\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await put(\n        this.fetch,\n        `${this.url}/bucket/${id}`,\n        {\n          id,\n          name: id,\n          public: options.public,\n          file_size_limit: options.fileSizeLimit,\n          allowed_mime_types: options.allowedMimeTypes,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Removes all objects inside a single bucket.\n   *\n   * @category File Buckets\n   * @param id The unique identifier of the bucket you would like to empty.\n   * @returns Promise with success message or error\n   *\n   * @example Empty bucket\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .emptyBucket('avatars')\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": {\n   *     \"message\": \"Successfully emptied\"\n   *   },\n   *   \"error\": null\n   * }\n   * ```\n   */\n  async emptyBucket(id: string): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/bucket/${id}/empty`,\n        {},\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n   * You must first `empty()` the bucket.\n   *\n   * @category File Buckets\n   * @param id The unique identifier of the bucket you would like to delete.\n   * @returns Promise with success message or error\n   *\n   * @example Delete bucket\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .deleteBucket('avatars')\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": {\n   *     \"message\": \"Successfully deleted\"\n   *   },\n   *   \"error\": null\n   * }\n   * ```\n   */\n  async deleteBucket(id: string): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await remove(\n        this.fetch,\n        `${this.url}/bucket/${id}`,\n        {},\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  private listBucketOptionsToQueryString(options?: ListBucketOptions): string {\n    const params: Record<string, string> = {}\n    if (options) {\n      if ('limit' in options) {\n        params.limit = String(options.limit)\n      }\n      if ('offset' in options) {\n        params.offset = String(options.offset)\n      }\n      if (options.search) {\n        params.search = options.search\n      }\n      if (options.sortColumn) {\n        params.sortColumn = options.sortColumn\n      }\n      if (options.sortOrder) {\n        params.sortOrder = options.sortOrder\n      }\n    }\n    return Object.keys(params).length > 0 ? '?' + new URLSearchParams(params).toString() : ''\n  }\n}\n","import { IcebergRestCatalog, IcebergError } from 'iceberg-js'\nimport { DEFAULT_HEADERS } from '../lib/constants'\nimport { isStorageError, StorageError } from '../lib/errors'\nimport { Fetch, get, post, remove } from '../lib/fetch'\nimport { isValidBucketName, resolveFetch } from '../lib/helpers'\nimport { AnalyticBucket } from '../lib/types'\n\ntype WrapAsyncMethod<T> = T extends (...args: infer A) => Promise<infer R>\n  ? (...args: A) => Promise<{ data: R; error: null } | { data: null; error: IcebergError }>\n  : T\n\nexport type WrappedIcebergRestCatalog = {\n  [K in keyof IcebergRestCatalog]: WrapAsyncMethod<IcebergRestCatalog[K]>\n}\n\n/**\n * Client class for managing Analytics Buckets using Iceberg tables\n * Provides methods for creating, listing, and deleting analytics buckets\n */\nexport default class StorageAnalyticsClient {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected fetch: Fetch\n  protected shouldThrowOnError = false\n\n  /**\n   * @alpha\n   *\n   * Creates a new StorageAnalyticsClient instance\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Analytics Buckets\n   * @param url - The base URL for the storage API\n   * @param headers - HTTP headers to include in requests\n   * @param fetch - Optional custom fetch implementation\n   *\n   * @example\n   * ```typescript\n   * const client = new StorageAnalyticsClient(url, headers)\n   * ```\n   */\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\n    this.url = url.replace(/\\/$/, '')\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * @alpha\n   *\n   * Enable throwing errors instead of returning them in the response\n   * When enabled, failed operations will throw instead of returning { data: null, error }\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Analytics Buckets\n   * @returns This instance for method chaining\n   */\n  public throwOnError(): this {\n    this.shouldThrowOnError = true\n    return this\n  }\n\n  /**\n   * @alpha\n   *\n   * Creates a new analytics bucket using Iceberg tables\n   * Analytics buckets are optimized for analytical queries and data processing\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Analytics Buckets\n   * @param name A unique name for the bucket you are creating\n   * @returns Promise with response containing newly created analytics bucket or error\n   *\n   * @example Create analytics bucket\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .analytics\n   *   .createBucket('analytics-data')\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": {\n   *     \"name\": \"analytics-data\",\n   *     \"type\": \"ANALYTICS\",\n   *     \"format\": \"iceberg\",\n   *     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n   *     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n   *   },\n   *   \"error\": null\n   * }\n   * ```\n   */\n  async createBucket(name: string): Promise<\n    | {\n        data: AnalyticBucket\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(this.fetch, `${this.url}/bucket`, { name }, { headers: this.headers })\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * @alpha\n   *\n   * Retrieves the details of all Analytics Storage buckets within an existing project\n   * Only returns buckets of type 'ANALYTICS'\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Analytics Buckets\n   * @param options Query parameters for listing buckets\n   * @param options.limit Maximum number of buckets to return\n   * @param options.offset Number of buckets to skip\n   * @param options.sortColumn Column to sort by ('name', 'created_at', 'updated_at')\n   * @param options.sortOrder Sort order ('asc' or 'desc')\n   * @param options.search Search term to filter bucket names\n   * @returns Promise with response containing array of analytics buckets or error\n   *\n   * @example List analytics buckets\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .analytics\n   *   .listBuckets({\n   *     limit: 10,\n   *     offset: 0,\n   *     sortColumn: 'created_at',\n   *     sortOrder: 'desc'\n   *   })\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": [\n   *     {\n   *       \"name\": \"analytics-data\",\n   *       \"type\": \"ANALYTICS\",\n   *       \"format\": \"iceberg\",\n   *       \"created_at\": \"2024-05-22T22:26:05.100Z\",\n   *       \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n   *     }\n   *   ],\n   *   \"error\": null\n   * }\n   * ```\n   */\n  async listBuckets(options?: {\n    limit?: number\n    offset?: number\n    sortColumn?: 'name' | 'created_at' | 'updated_at'\n    sortOrder?: 'asc' | 'desc'\n    search?: string\n  }): Promise<\n    | {\n        data: AnalyticBucket[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      // Build query string from options\n      const queryParams = new URLSearchParams()\n      if (options?.limit !== undefined) queryParams.set('limit', options.limit.toString())\n      if (options?.offset !== undefined) queryParams.set('offset', options.offset.toString())\n      if (options?.sortColumn) queryParams.set('sortColumn', options.sortColumn)\n      if (options?.sortOrder) queryParams.set('sortOrder', options.sortOrder)\n      if (options?.search) queryParams.set('search', options.search)\n\n      const queryString = queryParams.toString()\n      const url = queryString ? `${this.url}/bucket?${queryString}` : `${this.url}/bucket`\n\n      const data = await get(this.fetch, url, { headers: this.headers })\n\n      return { data: data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * @alpha\n   *\n   * Deletes an existing analytics bucket\n   * A bucket can't be deleted with existing objects inside it\n   * You must first empty the bucket before deletion\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Analytics Buckets\n   * @param bucketName The unique identifier of the bucket you would like to delete\n   * @returns Promise with response containing success message or error\n   *\n   * @example Delete analytics bucket\n   * ```js\n   * const { data, error } = await supabase\n   *   .storage\n   *   .analytics\n   *   .deleteBucket('analytics-data')\n   * ```\n   *\n   * Response:\n   * ```json\n   * {\n   *   \"data\": {\n   *     \"message\": \"Successfully deleted\"\n   *   },\n   *   \"error\": null\n   * }\n   * ```\n   */\n  async deleteBucket(bucketName: string): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await remove(\n        this.fetch,\n        `${this.url}/bucket/${bucketName}`,\n        {},\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * @alpha\n   *\n   * Get an Iceberg REST Catalog client configured for a specific analytics bucket\n   * Use this to perform advanced table and namespace operations within the bucket\n   * The returned client provides full access to the Apache Iceberg REST Catalog API\n   * with the Supabase `{ data, error }` pattern for consistent error handling on all operations.\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Analytics Buckets\n   * @param bucketName - The name of the analytics bucket (warehouse) to connect to\n   * @returns The wrapped Iceberg catalog client\n   * @throws {StorageError} If the bucket name is invalid\n   *\n   * @example Get catalog and create table\n   * ```js\n   * // First, create an analytics bucket\n   * const { data: bucket, error: bucketError } = await supabase\n   *   .storage\n   *   .analytics\n   *   .createBucket('analytics-data')\n   *\n   * // Get the Iceberg catalog for that bucket\n   * const catalog = supabase.storage.analytics.from('analytics-data')\n   *\n   * // Create a namespace\n   * const { error: nsError } = await catalog.createNamespace({ namespace: ['default'] })\n   *\n   * // Create a table with schema\n   * const { data: tableMetadata, error: tableError } = await catalog.createTable(\n   *   { namespace: ['default'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true },\n   *         { id: 3, name: 'user_id', type: 'string', required: false }\n   *       ],\n   *       'schema-id': 0,\n   *       'identifier-field-ids': [1]\n   *     },\n   *     'partition-spec': {\n   *       'spec-id': 0,\n   *       fields: []\n   *     },\n   *     'write-order': {\n   *       'order-id': 0,\n   *       fields: []\n   *     },\n   *     properties: {\n   *       'write.format.default': 'parquet'\n   *     }\n   *   }\n   * )\n   * ```\n   *\n   * @example List tables in namespace\n   * ```js\n   * const catalog = supabase.storage.analytics.from('analytics-data')\n   *\n   * // List all tables in the default namespace\n   * const { data: tables, error: listError } = await catalog.listTables({ namespace: ['default'] })\n   * if (listError) {\n   *   if (listError.isNotFound()) {\n   *     console.log('Namespace not found')\n   *   }\n   *   return\n   * }\n   * console.log(tables) // [{ namespace: ['default'], name: 'events' }]\n   * ```\n   *\n   * @example Working with namespaces\n   * ```js\n   * const catalog = supabase.storage.analytics.from('analytics-data')\n   *\n   * // List all namespaces\n   * const { data: namespaces } = await catalog.listNamespaces()\n   *\n   * // Create namespace with properties\n   * await catalog.createNamespace(\n   *   { namespace: ['production'] },\n   *   { properties: { owner: 'data-team', env: 'prod' } }\n   * )\n   * ```\n   *\n   * @example Cleanup operations\n   * ```js\n   * const catalog = supabase.storage.analytics.from('analytics-data')\n   *\n   * // Drop table with purge option (removes all data)\n   * const { error: dropError } = await catalog.dropTable(\n   *   { namespace: ['default'], name: 'events' },\n   *   { purge: true }\n   * )\n   *\n   * if (dropError?.isNotFound()) {\n   *   console.log('Table does not exist')\n   * }\n   *\n   * // Drop namespace (must be empty)\n   * await catalog.dropNamespace({ namespace: ['default'] })\n   * ```\n   *\n   * @remarks\n   * This method provides a bridge between Supabase's bucket management and the standard\n   * Apache Iceberg REST Catalog API. The bucket name maps to the Iceberg warehouse parameter.\n   * All authentication and configuration is handled automatically using your Supabase credentials.\n   *\n   * **Error Handling**: Invalid bucket names throw immediately. All catalog\n   * operations return `{ data, error }` where errors are `IcebergError` instances from iceberg-js.\n   * Use helper methods like `error.isNotFound()` or check `error.status` for specific error handling.\n   * Use `.throwOnError()` on the analytics client if you prefer exceptions for catalog operations.\n   *\n   * **Cleanup Operations**: When using `dropTable`, the `purge: true` option permanently\n   * deletes all table data. Without it, the table is marked as deleted but data remains.\n   *\n   * **Library Dependency**: The returned catalog wraps `IcebergRestCatalog` from iceberg-js.\n   * For complete API documentation and advanced usage, refer to the\n   * [iceberg-js documentation](https://supabase.github.io/iceberg-js/).\n   */\n  from(bucketName: string): WrappedIcebergRestCatalog {\n    // Validate bucket name using same rules as Supabase Storage API backend\n    if (!isValidBucketName(bucketName)) {\n      throw new StorageError(\n        'Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines ' +\n          'and should avoid the use of any other characters.'\n      )\n    }\n\n    // Construct the Iceberg REST Catalog URL\n    // The base URL is /storage/v1/iceberg\n    // Note: IcebergRestCatalog from iceberg-js automatically adds /v1/ prefix to API paths\n    // so we should NOT append /v1 here (it would cause double /v1/v1/ in the URL)\n    const catalog = new IcebergRestCatalog({\n      baseUrl: this.url,\n      catalogName: bucketName, // Maps to the warehouse parameter in Supabase's implementation\n      auth: {\n        type: 'custom',\n        getHeaders: async () => this.headers,\n      },\n      fetch: this.fetch,\n    })\n\n    const shouldThrowOnError = this.shouldThrowOnError\n\n    const wrappedCatalog = new Proxy(catalog, {\n      get(target, prop: keyof IcebergRestCatalog) {\n        const value = target[prop]\n        if (typeof value !== 'function') {\n          return value\n        }\n\n        return async (...args: unknown[]) => {\n          try {\n            const data = await (value as Function).apply(target, args)\n            return { data, error: null }\n          } catch (error) {\n            if (shouldThrowOnError) {\n              throw error\n            }\n            return { data: null, error: error as IcebergError }\n          }\n        }\n      },\n    }) as unknown as WrappedIcebergRestCatalog\n\n    return wrappedCatalog\n  }\n}\n","import { version } from '../version'\nexport const DEFAULT_HEADERS = {\n  'X-Client-Info': `storage-js/${version}`,\n  'Content-Type': 'application/json',\n}\n","/**\n * Base error class for all Storage Vectors errors\n */\nexport class StorageVectorsError extends Error {\n  protected __isStorageVectorsError = true\n\n  constructor(message: string) {\n    super(message)\n    this.name = 'StorageVectorsError'\n  }\n}\n\n/**\n * Type guard to check if an error is a StorageVectorsError\n * @param error - The error to check\n * @returns True if the error is a StorageVectorsError\n */\nexport function isStorageVectorsError(error: unknown): error is StorageVectorsError {\n  return typeof error === 'object' && error !== null && '__isStorageVectorsError' in error\n}\n\n/**\n * API error returned from S3 Vectors service\n * Includes HTTP status code and service-specific error code\n */\nexport class StorageVectorsApiError extends StorageVectorsError {\n  status: number\n  statusCode: string\n\n  constructor(message: string, status: number, statusCode: string) {\n    super(message)\n    this.name = 'StorageVectorsApiError'\n    this.status = status\n    this.statusCode = statusCode\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n      statusCode: this.statusCode,\n    }\n  }\n}\n\n/**\n * Unknown error that doesn't match expected error patterns\n * Wraps the original error for debugging\n */\nexport class StorageVectorsUnknownError extends StorageVectorsError {\n  originalError: unknown\n\n  constructor(message: string, originalError: unknown) {\n    super(message)\n    this.name = 'StorageVectorsUnknownError'\n    this.originalError = originalError\n  }\n}\n\n/**\n * Error codes specific to S3 Vectors API\n * Maps AWS service errors to application-friendly error codes\n */\nexport enum StorageVectorsErrorCode {\n  /** Internal server fault (HTTP 500) */\n  InternalError = 'InternalError',\n  /** Resource already exists / conflict (HTTP 409) */\n  S3VectorConflictException = 'S3VectorConflictException',\n  /** Resource not found (HTTP 404) */\n  S3VectorNotFoundException = 'S3VectorNotFoundException',\n  /** Delete bucket while not empty (HTTP 400) */\n  S3VectorBucketNotEmpty = 'S3VectorBucketNotEmpty',\n  /** Exceeds bucket quota/limit (HTTP 400) */\n  S3VectorMaxBucketsExceeded = 'S3VectorMaxBucketsExceeded',\n  /** Exceeds index quota/limit (HTTP 400) */\n  S3VectorMaxIndexesExceeded = 'S3VectorMaxIndexesExceeded',\n}\n","type Fetch = typeof fetch\n\n/**\n * Resolves the fetch implementation to use\n * Uses custom fetch if provided, otherwise uses native fetch\n *\n * @param customFetch - Optional custom fetch implementation\n * @returns Resolved fetch function\n */\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  if (customFetch) {\n    return (...args) => customFetch(...args)\n  }\n  return (...args) => fetch(...args)\n}\n\n/**\n * Resolves the Response constructor to use\n * Returns native Response constructor\n *\n * @returns Response constructor\n */\nexport const resolveResponse = (): typeof Response => {\n  return Response\n}\n\n/**\n * Determine if input is a plain object\n * An object is plain if it's created by either {}, new Object(), or Object.create(null)\n *\n * @param value - Value to check\n * @returns True if value is a plain object\n * @source https://github.com/sindresorhus/is-plain-obj\n */\nexport const isPlainObject = (value: object): boolean => {\n  if (typeof value !== 'object' || value === null) {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n  return (\n    (prototype === null ||\n      prototype === Object.prototype ||\n      Object.getPrototypeOf(prototype) === null) &&\n    !(Symbol.toStringTag in value) &&\n    !(Symbol.iterator in value)\n  )\n}\n\n/**\n * Normalizes a number array to float32 format\n * Ensures all vector values are valid 32-bit floats\n *\n * @param values - Array of numbers to normalize\n * @returns Normalized float32 array\n */\nexport const normalizeToFloat32 = (values: number[]): number[] => {\n  // Use Float32Array to ensure proper precision\n  return Array.from(new Float32Array(values))\n}\n\n/**\n * Validates vector dimensions match expected dimension\n * Throws error if dimensions don't match\n *\n * @param vector - Vector data to validate\n * @param expectedDimension - Expected vector dimension\n * @throws Error if dimensions don't match\n */\nexport const validateVectorDimension = (\n  vector: { float32: number[] },\n  expectedDimension?: number\n): void => {\n  if (expectedDimension !== undefined && vector.float32.length !== expectedDimension) {\n    throw new Error(\n      `Vector dimension mismatch: expected ${expectedDimension}, got ${vector.float32.length}`\n    )\n  }\n}\n","import { StorageVectorsApiError, StorageVectorsUnknownError } from './errors'\nimport { isPlainObject, resolveResponse } from './helpers'\nimport { VectorFetchParameters } from './types'\n\nexport type Fetch = typeof fetch\n\n/**\n * Options for fetch requests\n * @property headers - Custom HTTP headers\n * @property noResolveJson - If true, return raw Response instead of parsing JSON\n */\nexport interface FetchOptions {\n  headers?: {\n    [key: string]: string\n  }\n  noResolveJson?: boolean\n}\n\n/**\n * HTTP methods supported by the API\n */\nexport type RequestMethodType = 'GET' | 'POST' | 'PUT' | 'DELETE'\n\n/**\n * Extracts error message from various error response formats\n * @param err - Error object from API\n * @returns Human-readable error message\n */\nconst _getErrorMessage = (err: any): string =>\n  err.msg || err.message || err.error_description || err.error || JSON.stringify(err)\n\n/**\n * Handles fetch errors and converts them to StorageVectors error types\n * @param error - The error caught from fetch\n * @param reject - Promise rejection function\n * @param options - Fetch options that may affect error handling\n */\nconst handleError = async (\n  error: unknown,\n  reject: (reason?: any) => void,\n  options?: FetchOptions\n) => {\n  // Check if error is a Response-like object (has status and ok properties)\n  // This is more reliable than instanceof which can fail across realms\n  const isResponseLike =\n    error &&\n    typeof error === 'object' &&\n    'status' in error &&\n    'ok' in error &&\n    typeof (error as any).status === 'number'\n\n  if (isResponseLike && !options?.noResolveJson) {\n    const status = (error as any).status || 500\n    const responseError = error as any\n\n    // Try to parse JSON body if available\n    if (typeof responseError.json === 'function') {\n      responseError\n        .json()\n        .then((err: any) => {\n          const statusCode = err?.statusCode || err?.code || status + ''\n          reject(new StorageVectorsApiError(_getErrorMessage(err), status, statusCode))\n        })\n        .catch(() => {\n          // If JSON parsing fails, create an ApiError with the HTTP status code\n          const statusCode = status + ''\n          const message = responseError.statusText || `HTTP ${status} error`\n          reject(new StorageVectorsApiError(message, status, statusCode))\n        })\n    } else {\n      // No json() method available, create error from status\n      const statusCode = status + ''\n      const message = responseError.statusText || `HTTP ${status} error`\n      reject(new StorageVectorsApiError(message, status, statusCode))\n    }\n  } else {\n    reject(new StorageVectorsUnknownError(_getErrorMessage(error), error))\n  }\n}\n\n/**\n * Builds request parameters for fetch calls\n * @param method - HTTP method\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters like AbortSignal\n * @param body - Request body (will be JSON stringified if plain object)\n * @returns Complete fetch request parameters\n */\nconst _getRequestParams = (\n  method: RequestMethodType,\n  options?: FetchOptions,\n  parameters?: VectorFetchParameters,\n  body?: object\n) => {\n  const params: { [k: string]: any } = { method, headers: options?.headers || {} }\n\n  if (method === 'GET' || !body) {\n    return params\n  }\n\n  if (isPlainObject(body)) {\n    params.headers = { 'Content-Type': 'application/json', ...options?.headers }\n    params.body = JSON.stringify(body)\n  } else {\n    params.body = body\n  }\n\n  return { ...params, ...parameters }\n}\n\n/**\n * Internal request handler that wraps fetch with error handling\n * @param fetcher - Fetch function to use\n * @param method - HTTP method\n * @param url - Request URL\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @param body - Request body\n * @returns Promise with parsed response or error\n */\nasync function _handleRequest(\n  fetcher: Fetch,\n  method: RequestMethodType,\n  url: string,\n  options?: FetchOptions,\n  parameters?: VectorFetchParameters,\n  body?: object\n): Promise<any> {\n  return new Promise((resolve, reject) => {\n    fetcher(url, _getRequestParams(method, options, parameters, body))\n      .then((result) => {\n        if (!result.ok) throw result\n        if (options?.noResolveJson) return result\n        // Handle empty responses (204, empty body)\n        const contentType = result.headers.get('content-type')\n        if (!contentType || !contentType.includes('application/json')) {\n          return {}\n        }\n        return result.json()\n      })\n      .then((data) => resolve(data))\n      .catch((error) => handleError(error, reject, options))\n  })\n}\n\n/**\n * Performs a GET request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */\nexport async function get(\n  fetcher: Fetch,\n  url: string,\n  options?: FetchOptions,\n  parameters?: VectorFetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'GET', url, options, parameters)\n}\n\n/**\n * Performs a POST request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param body - Request body to be JSON stringified\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */\nexport async function post(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: VectorFetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'POST', url, options, parameters, body)\n}\n\n/**\n * Performs a PUT request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param body - Request body to be JSON stringified\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */\nexport async function put(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: VectorFetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'PUT', url, options, parameters, body)\n}\n\n/**\n * Performs a DELETE request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param body - Request body to be JSON stringified\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */\nexport async function remove(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: VectorFetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'DELETE', url, options, parameters, body)\n}\n","import { DEFAULT_HEADERS } from './constants'\nimport { isStorageVectorsError } from './errors'\nimport { Fetch, post } from './fetch'\nimport { resolveFetch } from './helpers'\nimport {\n  ApiResponse,\n  VectorIndex,\n  ListIndexesOptions,\n  ListIndexesResponse,\n  VectorDataType,\n  DistanceMetric,\n  MetadataConfiguration,\n} from './types'\n\n/**\n * @alpha\n *\n * Options for creating a vector index\n *\n * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n */\nexport interface CreateIndexOptions {\n  vectorBucketName: string\n  indexName: string\n  dataType: VectorDataType\n  dimension: number\n  distanceMetric: DistanceMetric\n  metadataConfiguration?: MetadataConfiguration\n}\n\n/**\n * @hidden\n * Base implementation for vector index operations.\n * Use {@link VectorBucketScope} via `supabase.storage.vectors.from('bucket')` instead.\n */\nexport default class VectorIndexApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected fetch: Fetch\n  protected shouldThrowOnError = false\n\n  /** Creates a new VectorIndexApi instance */\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\n    this.url = url.replace(/\\/$/, '')\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /** Enable throwing errors instead of returning them in the response */\n  public throwOnError(): this {\n    this.shouldThrowOnError = true\n    return this\n  }\n\n  /** Creates a new vector index within a bucket */\n  async createIndex(options: CreateIndexOptions): Promise<ApiResponse<undefined>> {\n    try {\n      const data = await post(this.fetch, `${this.url}/CreateIndex`, options, {\n        headers: this.headers,\n      })\n      return { data: data || {}, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /** Retrieves metadata for a specific vector index */\n  async getIndex(\n    vectorBucketName: string,\n    indexName: string\n  ): Promise<ApiResponse<{ index: VectorIndex }>> {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/GetIndex`,\n        { vectorBucketName, indexName },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /** Lists vector indexes within a bucket with optional filtering and pagination */\n  async listIndexes(options: ListIndexesOptions): Promise<ApiResponse<ListIndexesResponse>> {\n    try {\n      const data = await post(this.fetch, `${this.url}/ListIndexes`, options, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /** Deletes a vector index and all its data */\n  async deleteIndex(vectorBucketName: string, indexName: string): Promise<ApiResponse<undefined>> {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/DeleteIndex`,\n        { vectorBucketName, indexName },\n        { headers: this.headers }\n      )\n      return { data: data || {}, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n}\n","import { DEFAULT_HEADERS } from './constants'\nimport { isStorageVectorsError } from './errors'\nimport { Fetch, post } from './fetch'\nimport { resolveFetch } from './helpers'\nimport {\n  ApiResponse,\n  PutVectorsOptions,\n  GetVectorsOptions,\n  GetVectorsResponse,\n  DeleteVectorsOptions,\n  ListVectorsOptions,\n  ListVectorsResponse,\n  QueryVectorsOptions,\n  QueryVectorsResponse,\n} from './types'\n\n/**\n * @hidden\n * Base implementation for vector data operations.\n * Use {@link VectorIndexScope} via `supabase.storage.vectors.from('bucket').index('idx')` instead.\n */\nexport default class VectorDataApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected fetch: Fetch\n  protected shouldThrowOnError = false\n\n  /** Creates a new VectorDataApi instance */\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\n    this.url = url.replace(/\\/$/, '')\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /** Enable throwing errors instead of returning them in the response */\n  public throwOnError(): this {\n    this.shouldThrowOnError = true\n    return this\n  }\n\n  /** Inserts or updates vectors in batch (1-500 per request) */\n  async putVectors(options: PutVectorsOptions): Promise<ApiResponse<undefined>> {\n    try {\n      // Validate batch size\n      if (options.vectors.length < 1 || options.vectors.length > 500) {\n        throw new Error('Vector batch size must be between 1 and 500 items')\n      }\n\n      const data = await post(this.fetch, `${this.url}/PutVectors`, options, {\n        headers: this.headers,\n      })\n      return { data: data || {}, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /** Retrieves vectors by their keys in batch */\n  async getVectors(options: GetVectorsOptions): Promise<ApiResponse<GetVectorsResponse>> {\n    try {\n      const data = await post(this.fetch, `${this.url}/GetVectors`, options, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /** Lists vectors in an index with pagination */\n  async listVectors(options: ListVectorsOptions): Promise<ApiResponse<ListVectorsResponse>> {\n    try {\n      // Validate segment configuration\n      if (options.segmentCount !== undefined) {\n        if (options.segmentCount < 1 || options.segmentCount > 16) {\n          throw new Error('segmentCount must be between 1 and 16')\n        }\n        if (options.segmentIndex !== undefined) {\n          if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) {\n            throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`)\n          }\n        }\n      }\n\n      const data = await post(this.fetch, `${this.url}/ListVectors`, options, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /** Queries for similar vectors using approximate nearest neighbor search */\n  async queryVectors(options: QueryVectorsOptions): Promise<ApiResponse<QueryVectorsResponse>> {\n    try {\n      const data = await post(this.fetch, `${this.url}/QueryVectors`, options, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /** Deletes vectors by their keys in batch (1-500 per request) */\n  async deleteVectors(options: DeleteVectorsOptions): Promise<ApiResponse<undefined>> {\n    try {\n      // Validate batch size\n      if (options.keys.length < 1 || options.keys.length > 500) {\n        throw new Error('Keys batch size must be between 1 and 500 items')\n      }\n\n      const data = await post(this.fetch, `${this.url}/DeleteVectors`, options, {\n        headers: this.headers,\n      })\n      return { data: data || {}, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n}\n","import { DEFAULT_HEADERS } from './constants'\nimport { isStorageVectorsError } from './errors'\nimport { Fetch, post } from './fetch'\nimport { resolveFetch } from './helpers'\nimport {\n  ApiResponse,\n  VectorBucket,\n  ListVectorBucketsOptions,\n  ListVectorBucketsResponse,\n} from './types'\n\n/**\n * @hidden\n * Base implementation for vector bucket operations.\n * Use {@link StorageVectorsClient} via `supabase.storage.vectors` instead.\n */\nexport default class VectorBucketApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected fetch: Fetch\n  protected shouldThrowOnError = false\n\n  /** Creates a new VectorBucketApi instance */\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\n    this.url = url.replace(/\\/$/, '')\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /** Enable throwing errors instead of returning them in the response */\n  public throwOnError(): this {\n    this.shouldThrowOnError = true\n    return this\n  }\n\n  /** Creates a new vector bucket */\n  async createBucket(vectorBucketName: string): Promise<ApiResponse<undefined>> {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/CreateVectorBucket`,\n        { vectorBucketName },\n        { headers: this.headers }\n      )\n      return { data: data || {}, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /** Retrieves metadata for a specific vector bucket */\n  async getBucket(vectorBucketName: string): Promise<ApiResponse<{ vectorBucket: VectorBucket }>> {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/GetVectorBucket`,\n        { vectorBucketName },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /** Lists vector buckets with optional filtering and pagination */\n  async listBuckets(\n    options: ListVectorBucketsOptions = {}\n  ): Promise<ApiResponse<ListVectorBucketsResponse>> {\n    try {\n      const data = await post(this.fetch, `${this.url}/ListVectorBuckets`, options, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /** Deletes a vector bucket (must be empty first) */\n  async deleteBucket(vectorBucketName: string): Promise<ApiResponse<undefined>> {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/DeleteVectorBucket`,\n        { vectorBucketName },\n        { headers: this.headers }\n      )\n      return { data: data || {}, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n}\n","import VectorIndexApi, { CreateIndexOptions } from './VectorIndexApi'\nimport VectorDataApi from './VectorDataApi'\nimport { Fetch } from './fetch'\nimport VectorBucketApi from './VectorBucketApi'\nimport {\n  ApiResponse,\n  DeleteVectorsOptions,\n  GetVectorsOptions,\n  ListIndexesOptions,\n  ListVectorsOptions,\n  ListVectorBucketsOptions,\n  ListVectorBucketsResponse,\n  PutVectorsOptions,\n  QueryVectorsOptions,\n  VectorBucket,\n} from './types'\n\n/**\n *\n * @alpha\n *\n * Configuration options for the Storage Vectors client\n *\n * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n */\nexport interface StorageVectorsClientOptions {\n  /**\n   * Custom headers to include in all requests\n   */\n  headers?: { [key: string]: string }\n  /**\n   * Custom fetch implementation (optional)\n   * Useful for testing or custom request handling\n   */\n  fetch?: Fetch\n}\n\n/**\n *\n * @alpha\n *\n * Main client for interacting with S3 Vectors API\n * Provides access to bucket, index, and vector data operations\n *\n * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n *\n * **Usage Patterns:**\n *\n * ```typescript\n * const { data, error } = await supabase\n *  .storage\n *  .vectors\n *  .createBucket('embeddings-prod')\n *\n * // Access index operations via buckets\n * const bucket = supabase.storage.vectors.from('embeddings-prod')\n * await bucket.createIndex({\n *   indexName: 'documents',\n *   dataType: 'float32',\n *   dimension: 1536,\n *   distanceMetric: 'cosine'\n * })\n *\n * // Access vector operations via index\n * const index = bucket.index('documents')\n * await index.putVectors({\n *   vectors: [\n *     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n *   ]\n * })\n *\n * // Query similar vectors\n * const { data } = await index.queryVectors({\n *   queryVector: { float32: [...] },\n *   topK: 5,\n *   returnDistance: true\n * })\n * ```\n */\nexport class StorageVectorsClient extends VectorBucketApi {\n  /**\n   * @alpha\n   *\n   * Creates a StorageVectorsClient that can manage buckets, indexes, and vectors.\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param url - Base URL of the Storage Vectors REST API.\n   * @param options.headers - Optional headers (for example `Authorization`) applied to every request.\n   * @param options.fetch - Optional custom `fetch` implementation for non-browser runtimes.\n   *\n   * @example\n   * ```typescript\n   * const client = new StorageVectorsClient(url, options)\n   * ```\n   */\n  constructor(url: string, options: StorageVectorsClientOptions = {}) {\n    super(url, options.headers || {}, options.fetch)\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Access operations for a specific vector bucket\n   * Returns a scoped client for index and vector operations within the bucket\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param vectorBucketName - Name of the vector bucket\n   * @returns Bucket-scoped client with index and vector operations\n   *\n   * @example\n   * ```typescript\n   * const bucket = supabase.storage.vectors.from('embeddings-prod')\n   * ```\n   */\n  from(vectorBucketName: string): VectorBucketScope {\n    return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch)\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Creates a new vector bucket\n   * Vector buckets are containers for vector indexes and their data\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param vectorBucketName - Unique name for the vector bucket\n   * @returns Promise with empty response on success or error\n   *\n   * @example\n   * ```typescript\n   * const { data, error } = await supabase\n   *   .storage\n   *   .vectors\n   *   .createBucket('embeddings-prod')\n   * ```\n   */\n  async createBucket(vectorBucketName: string): Promise<ApiResponse<undefined>> {\n    return super.createBucket(vectorBucketName)\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Retrieves metadata for a specific vector bucket\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param vectorBucketName - Name of the vector bucket\n   * @returns Promise with bucket metadata or error\n   *\n   * @example\n   * ```typescript\n   * const { data, error } = await supabase\n   *   .storage\n   *   .vectors\n   *   .getBucket('embeddings-prod')\n   *\n   * console.log('Bucket created:', data?.vectorBucket.creationTime)\n   * ```\n   */\n  async getBucket(vectorBucketName: string): Promise<ApiResponse<{ vectorBucket: VectorBucket }>> {\n    return super.getBucket(vectorBucketName)\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Lists all vector buckets with optional filtering and pagination\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param options - Optional filters (prefix, maxResults, nextToken)\n   * @returns Promise with list of buckets or error\n   *\n   * @example\n   * ```typescript\n   * const { data, error } = await supabase\n   *   .storage\n   *   .vectors\n   *   .listBuckets({ prefix: 'embeddings-' })\n   *\n   * data?.vectorBuckets.forEach(bucket => {\n   *   console.log(bucket.vectorBucketName)\n   * })\n   * ```\n   */\n  async listBuckets(\n    options: ListVectorBucketsOptions = {}\n  ): Promise<ApiResponse<ListVectorBucketsResponse>> {\n    return super.listBuckets(options)\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Deletes a vector bucket (bucket must be empty)\n   * All indexes must be deleted before deleting the bucket\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param vectorBucketName - Name of the vector bucket to delete\n   * @returns Promise with empty response on success or error\n   *\n   * @example\n   * ```typescript\n   * const { data, error } = await supabase\n   *   .storage\n   *   .vectors\n   *   .deleteBucket('embeddings-old')\n   * ```\n   */\n  async deleteBucket(vectorBucketName: string): Promise<ApiResponse<undefined>> {\n    return super.deleteBucket(vectorBucketName)\n  }\n}\n\n/**\n *\n * @alpha\n *\n * Scoped client for operations within a specific vector bucket\n * Provides index management and access to vector operations\n *\n * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n */\nexport class VectorBucketScope extends VectorIndexApi {\n  private vectorBucketName: string\n\n  /**\n   * @alpha\n   *\n   * Creates a helper that automatically scopes all index operations to the provided bucket.\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @example\n   * ```typescript\n   * const bucket = supabase.storage.vectors.from('embeddings-prod')\n   * ```\n   */\n  constructor(\n    url: string,\n    headers: { [key: string]: string },\n    vectorBucketName: string,\n    fetch?: Fetch\n  ) {\n    super(url, headers, fetch)\n    this.vectorBucketName = vectorBucketName\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Creates a new vector index in this bucket\n   * Convenience method that automatically includes the bucket name\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param options - Index configuration (vectorBucketName is automatically set)\n   * @returns Promise with empty response on success or error\n   *\n   * @example\n   * ```typescript\n   * const bucket = supabase.storage.vectors.from('embeddings-prod')\n   * await bucket.createIndex({\n   *   indexName: 'documents-openai',\n   *   dataType: 'float32',\n   *   dimension: 1536,\n   *   distanceMetric: 'cosine',\n   *   metadataConfiguration: {\n   *     nonFilterableMetadataKeys: ['raw_text']\n   *   }\n   * })\n   * ```\n   */\n  override async createIndex(options: Omit<CreateIndexOptions, 'vectorBucketName'>) {\n    return super.createIndex({\n      ...options,\n      vectorBucketName: this.vectorBucketName,\n    })\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Lists indexes in this bucket\n   * Convenience method that automatically includes the bucket name\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param options - Listing options (vectorBucketName is automatically set)\n   * @returns Promise with response containing indexes array and pagination token or error\n   *\n   * @example\n   * ```typescript\n   * const bucket = supabase.storage.vectors.from('embeddings-prod')\n   * const { data } = await bucket.listIndexes({ prefix: 'documents-' })\n   * ```\n   */\n  override async listIndexes(options: Omit<ListIndexesOptions, 'vectorBucketName'> = {}) {\n    return super.listIndexes({\n      ...options,\n      vectorBucketName: this.vectorBucketName,\n    })\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Retrieves metadata for a specific index in this bucket\n   * Convenience method that automatically includes the bucket name\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param indexName - Name of the index to retrieve\n   * @returns Promise with index metadata or error\n   *\n   * @example\n   * ```typescript\n   * const bucket = supabase.storage.vectors.from('embeddings-prod')\n   * const { data } = await bucket.getIndex('documents-openai')\n   * console.log('Dimension:', data?.index.dimension)\n   * ```\n   */\n  override async getIndex(indexName: string) {\n    return super.getIndex(this.vectorBucketName, indexName)\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Deletes an index from this bucket\n   * Convenience method that automatically includes the bucket name\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param indexName - Name of the index to delete\n   * @returns Promise with empty response on success or error\n   *\n   * @example\n   * ```typescript\n   * const bucket = supabase.storage.vectors.from('embeddings-prod')\n   * await bucket.deleteIndex('old-index')\n   * ```\n   */\n  override async deleteIndex(indexName: string) {\n    return super.deleteIndex(this.vectorBucketName, indexName)\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Access operations for a specific index within this bucket\n   * Returns a scoped client for vector data operations\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param indexName - Name of the index\n   * @returns Index-scoped client with vector data operations\n   *\n   * @example\n   * ```typescript\n   * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n   *\n   * // Insert vectors\n   * await index.putVectors({\n   *   vectors: [\n   *     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n   *   ]\n   * })\n   *\n   * // Query similar vectors\n   * const { data } = await index.queryVectors({\n   *   queryVector: { float32: [...] },\n   *   topK: 5\n   * })\n   * ```\n   */\n  index(indexName: string): VectorIndexScope {\n    return new VectorIndexScope(\n      this.url,\n      this.headers,\n      this.vectorBucketName,\n      indexName,\n      this.fetch\n    )\n  }\n}\n\n/**\n *\n * @alpha\n *\n * Scoped client for operations within a specific vector index\n * Provides vector data operations (put, get, list, query, delete)\n *\n * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n */\nexport class VectorIndexScope extends VectorDataApi {\n  private vectorBucketName: string\n  private indexName: string\n\n  /**\n   *\n   * @alpha\n   *\n   * Creates a helper that automatically scopes all vector operations to the provided bucket/index names.\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @example\n   * ```typescript\n   * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n   * ```\n   */\n  constructor(\n    url: string,\n    headers: { [key: string]: string },\n    vectorBucketName: string,\n    indexName: string,\n    fetch?: Fetch\n  ) {\n    super(url, headers, fetch)\n    this.vectorBucketName = vectorBucketName\n    this.indexName = indexName\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Inserts or updates vectors in this index\n   * Convenience method that automatically includes bucket and index names\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param options - Vector insertion options (bucket and index names automatically set)\n   * @returns Promise with empty response on success or error\n   *\n   * @example\n   * ```typescript\n   * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n   * await index.putVectors({\n   *   vectors: [\n   *     {\n   *       key: 'doc-1',\n   *       data: { float32: [0.1, 0.2, ...] },\n   *       metadata: { title: 'Introduction', page: 1 }\n   *     }\n   *   ]\n   * })\n   * ```\n   */\n  override async putVectors(options: Omit<PutVectorsOptions, 'vectorBucketName' | 'indexName'>) {\n    return super.putVectors({\n      ...options,\n      vectorBucketName: this.vectorBucketName,\n      indexName: this.indexName,\n    })\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Retrieves vectors by keys from this index\n   * Convenience method that automatically includes bucket and index names\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param options - Vector retrieval options (bucket and index names automatically set)\n   * @returns Promise with response containing vectors array or error\n   *\n   * @example\n   * ```typescript\n   * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n   * const { data } = await index.getVectors({\n   *   keys: ['doc-1', 'doc-2'],\n   *   returnMetadata: true\n   * })\n   * ```\n   */\n  override async getVectors(options: Omit<GetVectorsOptions, 'vectorBucketName' | 'indexName'>) {\n    return super.getVectors({\n      ...options,\n      vectorBucketName: this.vectorBucketName,\n      indexName: this.indexName,\n    })\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Lists vectors in this index with pagination\n   * Convenience method that automatically includes bucket and index names\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param options - Listing options (bucket and index names automatically set)\n   * @returns Promise with response containing vectors array and pagination token or error\n   *\n   * @example\n   * ```typescript\n   * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n   * const { data } = await index.listVectors({\n   *   maxResults: 500,\n   *   returnMetadata: true\n   * })\n   * ```\n   */\n  override async listVectors(\n    options: Omit<ListVectorsOptions, 'vectorBucketName' | 'indexName'> = {}\n  ) {\n    return super.listVectors({\n      ...options,\n      vectorBucketName: this.vectorBucketName,\n      indexName: this.indexName,\n    })\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Queries for similar vectors in this index\n   * Convenience method that automatically includes bucket and index names\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param options - Query options (bucket and index names automatically set)\n   * @returns Promise with response containing matches array of similar vectors ordered by distance or error\n   *\n   * @example\n   * ```typescript\n   * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n   * const { data } = await index.queryVectors({\n   *   queryVector: { float32: [0.1, 0.2, ...] },\n   *   topK: 5,\n   *   filter: { category: 'technical' },\n   *   returnDistance: true,\n   *   returnMetadata: true\n   * })\n   * ```\n   */\n  override async queryVectors(\n    options: Omit<QueryVectorsOptions, 'vectorBucketName' | 'indexName'>\n  ) {\n    return super.queryVectors({\n      ...options,\n      vectorBucketName: this.vectorBucketName,\n      indexName: this.indexName,\n    })\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Deletes vectors by keys from this index\n   * Convenience method that automatically includes bucket and index names\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @param options - Deletion options (bucket and index names automatically set)\n   * @returns Promise with empty response on success or error\n   *\n   * @example\n   * ```typescript\n   * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n   * await index.deleteVectors({\n   *   keys: ['doc-1', 'doc-2', 'doc-3']\n   * })\n   * ```\n   */\n  override async deleteVectors(\n    options: Omit<DeleteVectorsOptions, 'vectorBucketName' | 'indexName'>\n  ) {\n    return super.deleteVectors({\n      ...options,\n      vectorBucketName: this.vectorBucketName,\n      indexName: this.indexName,\n    })\n  }\n}\n","import StorageFileApi from './packages/StorageFileApi'\nimport StorageBucketApi from './packages/StorageBucketApi'\nimport StorageAnalyticsClient from './packages/StorageAnalyticsClient'\nimport { Fetch } from './lib/fetch'\nimport { StorageVectorsClient } from './lib/vectors'\n\nexport interface StorageClientOptions {\n  useNewHostname?: boolean\n}\n\nexport class StorageClient extends StorageBucketApi {\n  /**\n   * Creates a client for Storage buckets, files, analytics, and vectors.\n   *\n   * @category File Buckets\n   * @example\n   * ```ts\n   * import { StorageClient } from '@supabase/storage-js'\n   *\n   * const storage = new StorageClient('https://xyzcompany.supabase.co/storage/v1', {\n   *   apikey: 'public-anon-key',\n   * })\n   * const avatars = storage.from('avatars')\n   * ```\n   */\n  constructor(\n    url: string,\n    headers: { [key: string]: string } = {},\n    fetch?: Fetch,\n    opts?: StorageClientOptions\n  ) {\n    super(url, headers, fetch, opts)\n  }\n\n  /**\n   * Perform file operation in a bucket.\n   *\n   * @category File Buckets\n   * @param id The bucket id to operate on.\n   *\n   * @example\n   * ```typescript\n   * const avatars = supabase.storage.from('avatars')\n   * ```\n   */\n  from(id: string): StorageFileApi {\n    return new StorageFileApi(this.url, this.headers, id, this.fetch)\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Access vector storage operations.\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Vector Buckets\n   * @returns A StorageVectorsClient instance configured with the current storage settings.\n   */\n  get vectors(): StorageVectorsClient {\n    return new StorageVectorsClient(this.url + '/vector', {\n      headers: this.headers,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   *\n   * @alpha\n   *\n   * Access analytics storage operations using Iceberg tables.\n   *\n   * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n   *\n   * @category Analytics Buckets\n   * @returns A StorageAnalyticsClient instance configured with the current storage settings.\n   */\n  get analytics(): StorageAnalyticsClient {\n    return new StorageAnalyticsClient(this.url + '/iceberg', this.headers, this.fetch)\n  }\n}\n"],"names":["resolveFetch","resolveResponse","result: Record<string, any>","isPlainObject","_getErrorMessage","handleError","resolveResponse","_getRequestParams","params: { [k: string]: any }","isPlainObject","_handleRequest","post","downloadFn: () => Promise<Response>","shouldThrowOnError: boolean","this","downloadFn: () => Promise<Response>","shouldThrowOnError: boolean","this","DEFAULT_FILE_OPTIONS: FileOptions","resolveFetch","fetch","headers: Record<string, string>","this","post","_queryString: string[]","params: string[]","DEFAULT_HEADERS","DEFAULT_HEADERS","resolveFetch","fetch","this","post","params: Record<string, string>","DEFAULT_HEADERS","resolveFetch","fetch","post","this","params: { [k: string]: any }","fetch","this","fetch","this","fetch","this","fetch","this","fetch"],"mappings":"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"}}]
}